(window.webpackJsonp=window.webpackJsonp||[]).push([[40],{565:function(v,_,l){"use strict";l.r(_);var t=l(4),a=Object(t.a)({},(function(){var v=this,_=v.$createElement,l=v._self._c||_;return l("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[l("div",{staticClass:"custom-block tip"},[l("p",[v._v("我们这次从几个一般常见的问题分析，主要有接口请求过慢或超时，程序突然崩（挂）了，CPU、内存居高不下或忽高忽低，硬盘容量不足等，这些可能是各种情况造成，我们从内存、CPU、线程、网络等（一般都是业务代码有问题）角度分析。")])]),v._v(" "),l("h2",{attrs:{id:"内存相关问题"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#内存相关问题"}},[v._v("#")]),v._v(" 内存相关问题")]),v._v(" "),l("h3",{attrs:{id:"一、jvm启动参数配置"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#一、jvm启动参数配置"}},[v._v("#")]),v._v(" 一、JVM启动参数配置")]),v._v(" "),l("p",[l("strong",[v._v("-Xms4g -Xmx4g：")]),v._v(" JVM堆内存的最小值、最大值设置为相等\n启动时会有预热过程（堆内存小于最小值），逐渐达到最小值\n启动时可直接向操作系统申请足够的内存（跳过预热）：-XX:+AlwaysPreTouch")]),v._v(" "),l("h3",{attrs:{id:"二、gc分析与调优"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#二、gc分析与调优"}},[v._v("#")]),v._v(" 二、GC分析与调优")]),v._v(" "),l("p",[l("strong",[v._v("GC分析，主要查看GC导致的stop-the-world，这将导致我们的程序延时增大。")])]),v._v(" "),l("ol",[l("li",[v._v("jcmd 查找运行中jar程序的进程号")]),v._v(" "),l("li",[v._v("jmap 打印heap的概要信息，GC使用的算法，heap的配置及wise heap的使用情况")]),v._v(" "),l("li",[v._v("-Xloggc 收集GC日志（日志离线分析，主要用于检查故障看出是不是因为GC导致的程序卡顿）")]),v._v(" "),l("li",[v._v("通过GCViewer工具，辅助分析GC日志文件")]),v._v(" "),l("li",[v._v("jstat 动态监控GC统计信息，间隔1000毫秒统计一次，每10行数据后输出列标题")])]),v._v(" "),l("p",[l("strong",[v._v("GC调优，切换回收器逐步调试， GC调优的过程就是对每个参数的含义了解后，再根据官方手册，一个个调试，找到符合应用的最佳配置点。是一个细致活，难度高。")])]),v._v(" "),l("ol",[l("li",[v._v("Parallel GC  服务器默认，UseAdaptiveSizePolicy自适应默认开启，所以Eden区会自动变化大小")]),v._v(" "),l("li",[v._v("尝试调大 -XX:ParallelGCThreads=4，如果有多线程，一定要调大参数")]),v._v(" "),l("li",[v._v("降低耗时，设置 -XX:MaxGCPauseMills=10，单次GC时间加速，会换来更多的GC次数。")]),v._v(" "),l("li",[v._v("改用CMS回收器 -XX:+UseConcMarkSweepGC，cms高频回收，会抢占用户线程，根据实际需要进行调优")]),v._v(" "),l("li",[v._v("增加线程 -XX:+UseConcMarkSweepGC -XX:ConcGCThreads=3")]),v._v(" "),l("li",[v._v("改用G1（建议大堆使用）-XX:+UseG1GC")]),v._v(" "),l("li",[v._v("增加分区大小 -XX:+UseG1GC -XX:G1HeapRegionSize=64m")])]),v._v(" "),l("p",[l("strong",[v._v("规避System.gc()带来的fullgc风险")])]),v._v(" "),l("ul",[l("li",[v._v("尽量提前做性能测试")]),v._v(" "),l("li",[v._v("禁用System.gc()显式调用（通常不建议）")]),v._v(" "),l("li",[v._v("小功能调用了System.gc()，也会导致其他功能受牵连，检查第三方包的使用情况")])]),v._v(" "),l("p",[l("strong",[v._v("线上环境出现FullGC类的问题处理")])]),v._v(" "),l("ul",[l("li",[v._v("问题现象描述：通过监控告警系统，提前收到应用FullGC告警等描述")]),v._v(" "),l("li",[v._v("问题的初步判断：是否版本变更引人？是否异常数据或请求导致")]),v._v(" "),l("li",[v._v("临时解决方案：保留现场+重启/回滚等运维措施")]),v._v(" "),l("li",[v._v("问题排查与分析：FullGC排查工具与分析过程（应用程序的日志分析、JVM的日志分析）")]),v._v(" "),l("li",[v._v("完整解决方案")]),v._v(" "),l("li",[v._v("故障总结")])]),v._v(" "),l("p",[l("strong",[v._v("OOM（OutOfMemory）内存溢出")])]),v._v(" "),l("ul",[l("li",[v._v("OOM 内存快照自动保存 -XX:+HeapDumpOnOutOfMemoryError")]),v._v(" "),l("li",[v._v("内存、CPU不要全部用完。 机器内存6G，那JVM的内存设置2/3，因为JVM自动处理操作，也是需要资源的")]),v._v(" "),l("li",[v._v("Eclipse Mat 内存快照的分析工具进行分析")]),v._v(" "),l("li",[v._v("Jmap可手动生成内存快照")])]),v._v(" "),l("p",[l("strong",[v._v("总结：")]),v._v(" 内存问题通过周全的测试是可以预防的，问题定位也比较直接，工具比较多~~ 一般问题往往是慢慢堆积的~内存占用会慢慢的升高，是可以通过监控工具发现问题，在宕机之前解决。开发时，借鉴线程安全~  接触到大数据的地方就有泄漏，频繁被执行也有可能出现泄漏。")]),v._v(" "),l("h2",{attrs:{id:"cpu相关问题"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#cpu相关问题"}},[v._v("#")]),v._v(" CPU相关问题")]),v._v(" "),l("p",[l("strong",[v._v("接口请求过慢")])]),v._v(" "),l("ul",[l("li",[v._v("现象：请求查询接口过慢，CPU、内存看起没问题")]),v._v(" "),l("li",[v._v("还原：通过 JMeter等测试工具模拟多个用户请求")]),v._v(" "),l("li",[v._v("jcmd 查找运行中jar程序的进程号")]),v._v(" "),l("li",[v._v("jstack 间隔性查看 jvm 线程情况（间隔时间 == 响应时间）")]),v._v(" "),l("li",[v._v("多次结果的比对，再根据package找出可疑线程（间隔时间后依然存在的线程）")])]),v._v(" "),l("p",[l("strong",[v._v("JAVA死锁问题")])]),v._v(" "),l("p",[v._v("jstack命令 显示Found one Java-level deadlock")]),v._v(" "),l("p",[l("strong",[v._v("CPU过高")])]),v._v(" "),l("ol",[l("li",[v._v("top命令找到CPU占用最大的线程")]),v._v(" "),l("li",[v._v("jstack 保存线程快照")]),v._v(" "),l("li",[v._v("找到线程ID（十进制 ）")]),v._v(" "),l("li",[v._v('十六进制转化命令： printf "%x\\n" 12345')]),v._v(" "),l("li",[v._v("Jstack 拿到的NID == top命令里面pid")]),v._v(" "),l("li",[v._v("查找分析")])]),v._v(" "),l("h2",{attrs:{id:"排除网络问题"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#排除网络问题"}},[v._v("#")]),v._v(" 排除网络问题")]),v._v(" "),l("ul",[l("li",[v._v("ping查看网络延迟")]),v._v(" "),l("li",[v._v("netstat 统计网络连接数")])]),v._v(" "),l("h2",{attrs:{id:"线上环境查找问题思路"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#线上环境查找问题思路"}},[v._v("#")]),v._v(" 线上环境查找问题思路")]),v._v(" "),l("ul",[l("li",[v._v("CPU")]),v._v(" "),l("li",[v._v("内存")]),v._v(" "),l("li",[v._v("网络")]),v._v(" "),l("li",[v._v("操作系统日志  tail -f /var/log/messages")]),v._v(" "),l("li",[v._v("日志文件的清理： log4j…file…. （大量公司的线上监控，是不完善的）")])]),v._v(" "),l("h2",{attrs:{id:"程序突然崩（挂）了"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#程序突然崩（挂）了"}},[v._v("#")]),v._v(" 程序突然崩（挂）了")]),v._v(" "),l("p",[v._v("jvm进程突然没有了，Linux ( Out Of Memory kill)  干掉jvm进程")])])}),[],!1,null,null,null);_.default=a.exports}}]);