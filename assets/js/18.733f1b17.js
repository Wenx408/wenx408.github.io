(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{547:function(t,v,e){"use strict";e.r(v);var r=e(4),_=Object(r.a)({},(function(){var t=this,v=t.$createElement,e=t._self._c||v;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h2",{attrs:{id:"jvm运行时数据区"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#jvm运行时数据区"}},[t._v("#")]),t._v(" JVM运行时数据区")]),t._v(" "),e("p",[t._v("class字节码开头0xcafebabe特殊标志")]),t._v(" "),e("p",[t._v("源代码.java 编译 -> 字节码.class -> JVM运行时数据区")]),t._v(" "),e("table",[e("thead",[e("tr",[e("th",{staticStyle:{"text-align":"center"}},[t._v("线程共享部分")]),t._v(" "),e("th",{staticStyle:{"text-align":"center"}},[t._v("线程独占部分")])])]),t._v(" "),e("tbody",[e("tr",[e("td",{staticStyle:{"text-align":"center"}},[t._v("方法区")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("虚拟机栈 | 本地方法栈")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"center"}},[t._v("堆内存")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("程序计数器")])])])]),t._v(" "),e("p",[e("strong",[t._v("线程独占：")]),t._v(" 每个线程都会有它独立的空间，随线程生命周期而创建和销毁")]),t._v(" "),e("p",[e("strong",[t._v("线程共享：")]),t._v(" 所有线程能访问这块内存数据，随虚拟机或者GC而创建和销毁")]),t._v(" "),e("p",[e("strong",[t._v("方法区：")]),t._v(" JVM用来存储加载的类信息、常量、静态变量、编译后的代码等数据。虚拟机规范中这是一个逻辑区划。具体实现根据不同虚拟机来实现。如：Oracle（Sun）的HotSpot在java7中方法区放在永久代，java8放在元数据空间，并且通过GC机制对这个区域进行管理")]),t._v(" "),e("p",[e("strong",[t._v("堆内存：")]),t._v(" 还可以细分为：老年代、新生代（Eden、From Survivor、To Survivor），JVM启动时创建，存放对象的实例，所有实例字段、静态字段和数组元素都存储在堆内存中。垃圾回收器主要就是管理堆内存。如果满了，就会出现OutOfMemroyError")]),t._v(" "),e("p",[e("strong",[t._v("虚拟机栈：")]),t._v(" 每个线程都在这个空间有一个私有空间。线程栈由多个栈帧（Stack Frame）组成。一个线程会执行一个或多个方法，一个方法对应一个栈帧。栈帧内容包含：局部变量表、操作数栈、动态链接、方法返回地址、附加信息等。栈内存默认最大是1M，超出则抛出StackOverflowError")]),t._v(" "),e("p",[e("strong",[t._v("本地方法栈：")]),t._v(" 和虚拟机栈功能类似，虚拟机栈是为虚拟机执行JAVA方法而准备的，本地方法栈是为虚拟机使用Native本地方法而准备的。虚拟机规范没有规定具体的实现，由不同虚拟机厂商去实现。HotSpot虚拟机中虚拟机栈和本地方法栈的实现是一样的。同样，超出大小以后也会抛出StackOverflowError")]),t._v(" "),e("p",[e("strong",[t._v("程序计数器：")]),t._v(" 记录当前线程执行字节码的位置，存储的是字节码指令地址，如果执行Native方法，则计数器值为空。每个线程都在这个空间有一个私有的空间，占用内存空间很少。CPU同一时间，只会执行一条线程中的指令。JVM多线程会轮流切换并分配CPU执行时间的方式。为了线程切换后，需要通过程序计数器，来恢复正确的执行位置。")]),t._v(" "),e("p",[e("strong",[t._v("反编译：")])]),t._v(" "),e("p",[t._v("javap -v Demo001.class > Demo001.txt")]),t._v(" "),e("p",[t._v("major version:52 //主版本号")]),t._v(" "),e("p",[t._v("版本号规则：JDK5 - 49，6 - 50，7 - 51，8 - 52")]),t._v(" "),e("p",[e("strong",[t._v("常量池：")]),t._v(" 运行时常量池在方法区中存放，用来存放字符串常量和基本类型常量")])])}),[],!1,null,null,null);v.default=_.exports}}]);