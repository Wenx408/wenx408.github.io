(window.webpackJsonp=window.webpackJsonp||[]).push([[36],{558:function(v,_,e){"use strict";e.r(_);var a=e(4),r=Object(a.a)({},(function(){var v=this,_=v.$createElement,e=v._self._c||_;return e("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[e("h2",{attrs:{id:"自动垃圾收集"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#自动垃圾收集"}},[v._v("#")]),v._v(" 自动垃圾收集")]),v._v(" "),e("p",[v._v("自动垃圾收集是查看堆内存，识别正在使用哪些对象以及哪些对象未被删除以及删除未使用对象的过程。")]),v._v(" "),e("p",[v._v("使用中的对象或引用的对象意味着程序的某些部分仍然维护指向该对象的指针。")]),v._v(" "),e("p",[v._v("程序的任何部分都不再引用未使用的对象或未引用的对象，因此可以回收未引用对象使用的内存。")]),v._v(" "),e("p",[v._v("像C这样的编程语言中，分配和释放内存是一个手动过程。")]),v._v(" "),e("p",[v._v("在Java中，解除分配内存的过程由垃圾收集器自动处理。")]),v._v(" "),e("h2",{attrs:{id:"如何确定内存需要被回收"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#如何确定内存需要被回收"}},[v._v("#")]),v._v(" 如何确定内存需要被回收")]),v._v(" "),e("p",[v._v("该过程的第一步称为标记。这是垃圾收集器识别哪些内存正在使用而哪些不在使用的地方。")]),v._v(" "),e("p",[v._v("不同类型内存的判断方式")]),v._v(" "),e("ul",[e("li",[v._v("对象回收 - 引用计数")]),v._v(" "),e("li",[v._v("对象回收 - 可达性分析")]),v._v(" "),e("li",[v._v("方法区回收")])]),v._v(" "),e("h2",{attrs:{id:"可达性分析算法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#可达性分析算法"}},[v._v("#")]),v._v(" 可达性分析算法")]),v._v(" "),e("p",[v._v("简单来说，将对象及其引用关系看作一个图，选定活动的对象作为 GC Roots；")]),v._v(" "),e("p",[v._v("然后跟踪引用链条，如果一个对象和 GC Roots 之间不可达，也就是不存在引用，那么即可认为是可回收对象")]),v._v(" "),e("p",[v._v("可以作为GC Roots的对象")]),v._v(" "),e("ol",[e("li",[v._v("虚拟机栈中正在引用的对象")]),v._v(" "),e("li",[v._v("本地方法栈中正在引用的对象")]),v._v(" "),e("li",[v._v("静态属性引用的对象")]),v._v(" "),e("li",[v._v("方法区常量引用的对象")])]),v._v(" "),e("h2",{attrs:{id:"引用类型和可达性级别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#引用类型和可达性级别"}},[v._v("#")]),v._v(" 引用类型和可达性级别")]),v._v(" "),e("p",[e("strong",[v._v("引用类型：")])]),v._v(" "),e("ol",[e("li",[e("strong",[v._v("强引用(StrongReference)：")]),v._v(" 最常见的普通对象引用，只要还有强引用指向一个对象，就不会回收。")]),v._v(" "),e("li",[e("strong",[v._v("软引用(SoftReference)：")]),v._v(" JVM认为内存不足时，才会去试图回收软引用指向的对象。（缓存场景）")]),v._v(" "),e("li",[e("strong",[v._v("弱引用(WeakReference)：")]),v._v(" 虽然是引用，但随时可能被回收掉。")]),v._v(" "),e("li",[e("strong",[v._v("虚引用(PhantomReference)：")]),v._v(" 不能通过它访问对象。提供了对象被finalize以后，执行指定逻辑的机制(Cleaner)")])]),v._v(" "),e("p",[e("strong",[v._v("可达性级别：")])]),v._v(" "),e("ol",[e("li",[e("strong",[v._v("强可达(Strongly Reachable)：")]),v._v(" 一个对象可以有一个或多个线程可以不通过各种引用访问到的情况。")]),v._v(" "),e("li",[e("strong",[v._v("软可达(Softly Reachable)：")]),v._v(" 就是当我们只能通过软引用才能访问到对象的状态。")]),v._v(" "),e("li",[e("strong",[v._v("弱可达(Weakly Reachable)：")]),v._v(" 只能通过弱引用访问到时的状态。当弱引用被清除的时候，就符合销毁条件。")]),v._v(" "),e("li",[e("strong",[v._v("幻象可达(Phantom Reachable)：")]),v._v(" 不存在其他引用，并且finalize过了，只有幻象引用指向这个对象。")]),v._v(" "),e("li",[e("strong",[v._v("不可达(unreachable)：")]),v._v(" 意味着对象可以被清除了。")])]),v._v(" "),e("h2",{attrs:{id:"垃圾收集算法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#垃圾收集算法"}},[v._v("#")]),v._v(" 垃圾收集算法")]),v._v(" "),e("p",[e("strong",[v._v("标记 - 清除(Mark-Sweep)算法：")]),v._v(" 首先标识出所有要回收的对象，然后进行清除。")]),v._v(" "),e("p",[v._v("标记、清除过程效率有限，有内存碎片化问题，不适合特别大的堆；收集算法基本基于标记 - 清除的思路进行改进。")]),v._v(" "),e("p",[e("strong",[v._v("复制(Copying)算法：")]),v._v(" 划分两块同等大小的区域，收集时将活着的对象复制到另一块区域。")]),v._v(" "),e("p",[v._v("拷贝过程中将对象顺序放置，就可以避免内存碎片化。复制+预留内存，有一定的浪费。")]),v._v(" "),e("p",[e("strong",[v._v("标记 - 整理(Mark-Compact)：")]),v._v(" 类似标记 - 清除，但为避免内存碎片化，它会在清理过程中将对象移动，以确保移动后的对象占用连续的内存空间。")]),v._v(" "),e("h2",{attrs:{id:"分代收集"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#分代收集"}},[v._v("#")]),v._v(" 分代收集")]),v._v(" "),e("p",[v._v("根据对象的存活周期，将内存划分为几个区域，不同区域采用合适的垃圾收集算法。")]),v._v(" "),e("p",[v._v("新对象会分配到Eden，如果超过 -XX:+PretenureSizeThreshold 设置大对象直接进入老年代的阀值。")]),v._v(" "),e("p",[v._v("新生代 Eden : S0 : S1 -> 8 : 1 : 1")]),v._v(" "),e("p",[v._v("新生代(复制算法) : 老年代(标记 - 整理)  -> 1 : 2")]),v._v(" "),e("h2",{attrs:{id:"垃圾收集器"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#垃圾收集器"}},[v._v("#")]),v._v(" 垃圾收集器")]),v._v(" "),e("p",[e("strong",[v._v("串行收集器")]),v._v(" - Serial GC -XX:+UseSerialGC")]),v._v(" "),e("p",[v._v("单个线程来执行所有垃圾收集工作，适合单处理器机器。")]),v._v(" "),e("p",[v._v("Client 模式下 JVM 的默认选项")]),v._v(" "),e("p",[e("strong",[v._v("串行收集器")]),v._v(" - Serial Old -XX:+UseSerialOldGC")]),v._v(" "),e("p",[v._v("可以在老年代使用，它采用了标记 - 整理(Mark-Compact)算法，区别于新生代的复制算法")]),v._v(" "),e("p",[e("strong",[v._v("并行收集器")]),v._v(" - Parallel GC -XX:+UseParallelGC")]),v._v(" "),e("p",[e("strong",[v._v("并行收集器")]),v._v(" - Parallel Old -XX:+UseParallelOldGC")]),v._v(" "),e("p",[v._v("server 模式 JVM 的默认 GC 选择，整体算法和 Serial 比较相似，区别是新生代和老年代 GC 都是并行进行；")]),v._v(" "),e("p",[v._v("可以设置GC 时间或吞吐量等值，可以自动进行适应性调整Eden，Survivor大小和MaxTenuringThreshold的值。")]),v._v(" "),e("p",[v._v("也称为吞吐量优先的GC：吞吐量 = 用户代码运行时间 / (用户代码运行时间 + GC时间)")]),v._v(" "),e("p",[v._v("-XX:+ParallelGCThreads：设置用于垃圾回收的线程数。通常情况下可以和CPU数量相等。")]),v._v(" "),e("p",[v._v("-XX:+MaxGCPauseMills：设置最大垃圾收集停顿时间。它的值是一个大于0的整数。")]),v._v(" "),e("p",[v._v("-XX:+GCTimeRatio：设置吞吐量大小，它的值是一个0-100之间的整数。")]),v._v(" "),e("p",[v._v("-XX:+UseAdaptiveSizePolicy：打开自适应GC策略。以达到在堆大小、吞吐量和停顿时间之间的平衡点。")]),v._v(" "),e("p",[e("strong",[v._v("并发收集器")]),v._v(" - CMS（Concurrent Mark Sweep）GC -XX:+UseConcMarkSweepGC")]),v._v(" "),e("p",[v._v("专用老年代，基于标记 - 清除（Mark-Sweep）算法，设计目标是尽量减少停顿时间。")]),v._v(" "),e("p",[v._v("采用标记 - 清除算法，存在着内存碎片化问题，长时间运行等情况下发生 full GC，导致恶劣的停顿。")]),v._v(" "),e("p",[v._v("CMS会占用更多CPU资源，并和用户线程争抢。")]),v._v(" "),e("p",[v._v("减少了停顿时间，这一点对互联网web等对时间敏感的系统非常重要，一直到今天，仍然有很多系统使用CMSGC")]),v._v(" "),e("p",[e("strong",[v._v("并行收集器")]),v._v(" - ParNew GC -XX:+UseParNewGC")]),v._v(" "),e("p",[v._v("新生代GC实现，它实际是Serial GC 的多线程版本。")]),v._v(" "),e("p",[v._v("可以控制线程数量，参数：-XX:+ParallelGCThreads")]),v._v(" "),e("p",[v._v("最常见的应用场景是配合老年代的 CMS GC 工作。参数-XX:+UseConcMarkSweepGC")]),v._v(" "),e("p",[e("strong",[v._v("并行收集器")]),v._v(" - G1 -XX:+UseG1GC")]),v._v(" "),e("p",[v._v("针对大堆内存设计的收集器，兼顾吞吐量和停顿时间，JDK9后为默认选型，目标是替代CMD；")]),v._v(" "),e("p",[v._v("G1将堆分成固定大小的区域，Region之间是复制算法，但整体上实际可看作是标记 - 清除（Mark-Sweep）算法，可以有效地避免内存碎片。红色新生代(Eden和Survivor)，淡蓝色老年代。找不到大内存时执行FullGC。")])])}),[],!1,null,null,null);_.default=r.exports}}]);